VNCviewer:共享我的屏幕给大家看
feiq:局域网的QQ,可以下载上面共享的文件
VM+ubuntu:
    VM:威睿公司发明一款虚拟机的软件
    ubuntu:基于linux内核的带图形界面的linux操作系统

    实现共享文件夹的设置:
        共享文件夹:用来实现你的电脑和虚拟机之间的互通
        设置步骤:
            在自己的电脑上创建一个文件夹
            第二步,打开虚拟机
                左上角Player ---> 管理 ----> 虚拟机设置
                ---> 选项 ---> 选择共享文件夹 点击添加 添加你刚刚创建的那个文件夹


0.本次项目介绍 
    电子相册
        实现显示图片和滑动切换图片的功能

    编程语言:C语言
    会用到的知识点:
        ubuntu的使用 
        文件IO 
        bmp图片显示
        开发板的滑动触摸 
        交叉开发


1.linux的基础操作
    (1)打开终端
        终端是整个ubuntu操作的核心 
        他是用户和内核之间的桥梁 
            用户在终端上输入指令 ,内核就会收到指令,并且对指令
            做出反馈,再显示到终端上


    (2)linux的文件系统 
        "一切且文件"
        linux是一个树形的组织 
            以根目录"/"为树的跟

        在linux下的文件和目录都有一个对应的路径 

            绝对路径:
                以根目录开头的路径名 
                共享文件夹的路径:
                    /mnt/hgfs/共享文件夹名字

            相对路径:
                不以根目录开头的路径名

                相对于当前所在目录的上一个
                    ../

                当前的目录
                    ./

    (3)几个简单的linux基础指令
        ls:list 列举 
            ls用来列举一个目录下所有文件的文件名
            使用方法:
                ls 回车

        cd:change directory 切换目录 
            改变我们的工作目录 
            使用方法:
                cd 你要切换的那个路径

            例子:
                进入共享文件夹的命令 
                cd /mnt/hgfs/你的共享文件夹

                可以在输入路径的时候按下TAB键进行补全你的路径信息

        rm:remove 删除 删除一个文件或者目录 
            删除文件 
                rm 要删除的文件名 
            删除目录
                rm -rf 要删除的目录名


        gcc指令:用来编译C程序 
            gcc/arm-linux-gcc 需要编译的.c文件 回车 
                会生成一个叫做a.out的可执行文件 
                    ./a.out 执行可执行文件 

            gcc/arm-linux-gcc 需要编译的.c文件 -o 你要指定的可执行文件名 
                会生成一个指定的可执行的文件名 
                    ./可执行文件名 


        练习:
            在ubuntu上编译个一个C程序

            S1:在你的共享文件夹中创建一个.c文件 

            S2:编写好你的C程序 并且在虚拟机中进入你的共享文件夹 
                找到你的.c程序


2.交叉开发 
    连接使用开发板 
    请大家下载一个USB转串口驱动和secure文件夹 


    (1)什么是交叉开发?
        开发一个项目的时候,有两台计算机,一台计算机负责编写和编译代码(ubuntu)
        另外一台计算机就负责运行这个编写好的程序

        在一个环境下进行代码的编写和编译,在另外一个环境上进行代码的运行 

        在ubuntu上进行代码的编译(x86)
        在ARM开发板上进行程序的运行(ARM)

        在进行交叉开发的时候,编译程序的指令需要从gcc ---> arm-linux-gcc

    (2)连接开发板
        把电源接好,用串口线连接电脑和开发板

        安装USB转串口驱动

        打开设备管理器 
            右键win图标 
                ----> 端口 ----> USB-SERIAL CH340(COMx)
                驱动已经安装完成


        打开secure文件夹
            在里面找到一个SecureCRT.exe的应用程序

            点击运行secureCRT  
            点击文件 --- 快速连接 

            协议:serial 
            端口:选择你刚刚查看到的那个端口
            波特率:115200
            其他的不用变 
            右边的流控去掉

            点击连接 ,如果出现了绿色的√就是连接成功了 
            按下ctrl+c 进入终端界面 

            如果连接失败 
                先把波特率改成9600,连接成功之后
                断开,再选择115200进行连接


    (3)传输可执行文件到开发板上运行 
        通过串口进行通信 
            首先大家要准备好可执行程序进行传输
            由arm-linux-gcc 得来的可执行程序

        首先创建一个属于自己的工作目录 
            以后每次连接开发板就是进入工作目录
            cd /IOT 回车
            再输入指令 
            mkdir 你的文件夹的名字 

            以后每次进入开发板都请先输入指令 
            cd /IOT/你自己创建的工作目录


        然后我们再准备一个可执行文件进行传输 
            这个可执行文件必须是arm-linux-gcc 编译得来的可执行程序
            在secure上执行
            S1:
                rx 你要传输的文件名 回车     

            S2:       
                选择传输 ---> 发送xmodem --> 选中你的要发送的可执行文件 点击发送

            S3: 
                执行之前需要添加可执行权限 
                    chmod +x 你的可执行文件名


3.LCD显示屏 
    (1)显示屏的原理
        尺寸:7寸 
        分辨率:800*480(每一行有800个像素点,总共有480行)
            像素点:就是能够显示某种颜色的点

        如何来操作LCD的显示屏?
            6818开发板带了一个OS,linux,操作系统的作用
            就是能够让我们不需要过多的去关注硬件,只需要
            把显示颜色的代码写好,OS会自己实现硬件相关的
            细节

        如何来描述一个颜色值?
            所有的颜色都是由三基色来组成 
                红 绿 蓝 

            如何来描述一个颜色的程度?
                红 很红 非常红
                "量化":数量化,用数值的大小来描述颜色的程度


            在像素点中,每个颜色分量占1个字节(8bits) 
                0x00 - 0xff 
            
            描述一个最红的红色 
                红      绿      蓝 
                0xff    0x00    0x00  ===> 0xff0000 

            在LCD显示屏中的像素点,除了三个颜色分量,还有一个字节的数据透明度 
            一个像素点占四个字节 ARGB
                int 四个字节 
                int color;
                color = 0xff0000;

    (2)OS的作用 
        为了实现能够对不同的硬件也可以实现相同的操作
        在OS中,有人就提出来在内存中开辟一块区域,上面用来保存每个像素点的
        颜色值,在通过应用程序把颜色值写入到这块内存中

        这块内存至少有多大:
            800*480*4 (LCD一共有800*480个像素点,每一个像素点占4个字节)

        这一块内存在linux中被称做:帧缓冲 Frame Buffer

        帧缓冲其实就是对具体的图像显示设备的一种抽象,他让上层应用不需要关心具体的硬件
        实现细节
            帧缓冲的工作原理:
                在内存区域填充合适的颜色 
                帧缓冲的驱动就会慢慢把颜色刷新到屏幕上


        帧缓冲这块内存到底该如何操作?
            在linux中,其实有一个底层的驱动文件对应着
            在开发板的 /dev/fb0 

            只需要把颜色写入到fb0文件中,底层帧缓冲驱动就会把颜色刷新到屏幕上

            准备一个颜色数组:
                int color[800*480] = {0};
                int i;
                for(i = 0;i < 800*480;i++)
                {
                    color[i] = 0xff0000;
                }

            到这一步之后,已经准备好颜色数组,下面只需要知道如何去操作文件即可


4.文件IO 
    IO:input/output
    文件IO:就是对文件进行读写操作 

    操作一个文件分为几步?
        打开文件 
        对文件进行读写
        关闭文件 

    OS提供了非常多的API函数,我们直接去调用就OK 
    在linux有一个指令,可以帮助我们查询需要使用的API 
        man 

    
    (1)open 打开文件 
        NAME
            open, - open and possibly create a file

        SYNOPSIS
            #include <sys/types.h>
            #include <sys/stat.h>
            #include <fcntl.h>

            int open(const char *pathname, int flags);
            参数列表:
                pathname:你要打开的这个文件的路径名 
                    绝对路径和相对路径都可以 
                    "/dev/fb0"

                flags:打开文件的标志 
                    只读:O_RDONLY
                    只写:O_WRONLY
                    可读可写:O_RDWR

            返回值:
                成功返回一个文件描述符fd,后续如果你需要继续操作这个文件,就直接通过
                文件描述符来进行操作 

                失败返回-1


            例子:
                //打开显示屏 
                int lcd_fd = open("/dev/fb0",O_RDWR);
                if(lcd_fd == -1)
                {
                    printf("open lcd fail\n");
                    return 0;
                }
            

    (2)close 关闭文件 
        NAME
            close - close a file descriptor

        SYNOPSIS
            #include <unistd.h>

            int close(int fd);
            //关闭一个文件描述符
            参数列表:
                open的返回值

    (3)write 写内容到文件中
        NAME
            write - write to a file descriptor
            通过一个文件描述符往文件中写入内容
        SYNOPSIS
            #include <unistd.h>

            ssize_t write(int fd, const void *buf, size_t count);
            参数列表:
                fd:你要操作的那个文件的文件描述符
                buf:你要写入的数据的首地址
                count:你要写入的字节数的大小
            
            返回值:
                成功返回成功写入的字节数 
                失败返回-1


        例子:
            //把颜色数组写入到文件描述付中 
            write(lcd_fd,color,800*480*4);


    (4)read 从文件中读取内容 
        NAME
            read - read from a file descriptor

        SYNOPSIS
            #include <unistd.h>

            ssize_t read(int fd, void *buf, size_t count);
            参数列表: 
                fd:文件描述符,你要读取的那个文件 
                buf:你要把读取的数据保存的地方的首地址
                count:你要读取的字节数
            
            返回值:
                成功返回成功读取的字节数 
                失败返回-1

    可以来检测以下你的开发板屏幕颜色是否能够正确显示

    刚刚在使用文件IO的时候,有一个效率的问题
        在使用write函数的时候,经过用户态和内核态的转换
        函数的调用也比较耗时间

    为了提高显示的效率:
        换更好的设备;
        改进显示的方法


5.内存映射 
    因为帧缓冲是一块内存,在C语言中,只要知道一块内存的首地址,就可以通过指针来操作这一块内存

    假设:
        定义一个指针指向帧缓冲的首地址
        int *plcd;
        *plcd = 0xff0000;//给屏幕最左上角的那个顶点进行上色
        *(plcd+1) = 0xff0000;//给下一个点进行上色
        ....

        给任意的一个点(x,y)来上色
        (0,0)----------------------------------->x 
        |
        |
        |
        |               (x,y)
        |
        |
        |
        y

        要通过指针plcd来找到(x,y)的地址
        我们需要知道在点(x,y)之前距离原点
        有多少个像素点
            距离原点有y行,每一行有800个像素点 
            距离当前行的第一个有x个像素点 

            距离原点的像素点的个数:
                800*y + x 

            *(plcd + 800*y + x) = color 

        ==============>
            画点函数 
                void lcd_draw_point(int x,int y,int color)
                {
                    //判断这个点是否在帧缓冲的范围内
                    if(x >= 0 && x < 800 && y >= 0 && y < 480)
                    {
                        *(plcd + 800*y + x) = color;
                    }
                } 


        上面分析完之后,还是有问题,我们如何来获取帧缓冲的首地址?
            有一个API函数来帮助我们获取首地址 
                内存映射 mmap函数 

        NAME
            mmap, munmap - map or unmap files or devices into memory
                内存映射: 映射内核或者文件的一块内存到应用空间 
                    如果你想操作这个文件,只需要操作这一块内存即可
        SYNOPSIS
            #include <sys/mman.h>

            void *mmap(void *addr, size_t length, int prot, int flags,
                        int fd, off_t offset);
            //内存映射 
            参数列表:
                addr:地址,文件需要映射到内存的哪一个地址 
                    一般填NULL ,由OS自动分配

                length:长度,需要映射多大的内存,内核会向上进行取整
                    8008480*4 
                
                prot:指定映射区域的权限(和打开文件的权限类似)
                    位域实现 
                        读写:PROT_READ|PROT_WRITE
                
                flags:映射标志 
                    MAP_SHARED:共享映射,你对映射区域的操作会立即反馈到文件或者内核

                fd:文件描述符 
                    你需要映射的那个文件的文件描述符 
                
                offset:偏移量 
                    从文件的哪个位置开始映射 0

            返回值:
                成功返回映射后区域的首地址 
                失败返回MAP_FAILED

            //解除映射
            int munmap(void *addr, size_t length);
            参数列表: 
                addr:需要解除映射的地址,mmap的返回值 
                length:需要解除映射空间的大小


    用映射的代码来在lcd上显示一个颜色


6.bmp图片显示
    (1)什么是bmp?
        bmp--->bitmap位图文件,是微软公司发明的一款无压缩的图片文件格式 
            无压缩:每一个像素点到的原始像素数据都保存在文件中

        bmp图片分为两种:
            24位bmp图片:每一个像素点占3个字节
            32位bmp图片:每一个像素点占4个字节 

            图片都是由一张一张的像素点组成的 ,去显示一张图片就是去解析这个图片的信息,再一一对应显示像素点 


    (2)bmp图片格式的解析
        1)bitmap文件头 
            有文件的格式和文件的大小,标识文件是否为bmp图片 
                固定占14个字节

        2)DIB头
            提供图像的尺寸,色深,色彩平面数,压缩方式等等 
                固定占40个字节

                a.宽度 width 偏移量:0x12 从这个位置开始的四个字节 
                    int width;
                    lseek(bmp_fd,0x12,SEEK_SET);//把光标移动到文件的0x12的位置
                    read(bmp_fd,&width,4);

                    >0  每一行的像素点从左往右保存
                    <0  每一行的像素点从右往左保存

                b.高度 heigth 偏移量:0x16 从这个位置开始四个字节 
                    int heigth;
                    lseek(bmp_fd,0x16,SEEK_SET);
                    read(bmp_fd,&heigth,4);

                    >0  每一列的像素点从下往上保存 
                    <0  每一列的像素点从上往下保存

                c.色深 depth 偏移量:0x1c 从这里开始的两个字节
                    色深就是每个像素点的大小
                    short depth;
                    lseek(bmp_fd,0x1c,SEEK_SET);
                    read(bmp_fd,&depth,2);

                    色深的值只可能是1 4 8 16 24 32

        3)调色板 
            可有可无 现在已经不用这个东西


        4)像素数组 
            图像的数据区域,保存了每一个像素点的颜色分量
            偏移量:0x36 从文件开始的第54个字节 

            大小根据色深的不同,大小也不一样 
            depth = 24 
                每个像素点占3个字节 

            depth = 32 
                每个像素点占4个字节 

            一般的来说,假设一张图片默认为 width > 0  heigth > 0
                像素点的排布顺序:从左往右 从下往上
                他的颜色分量是按行来存放的
                windows规定:
                    每一行的像素点的大小字节数必须为4的整数倍 

                    width = 10
                    depth = 24 
                    一行的字节数 = 24/8 * 10 = 30
                    所以为了满足上面的那个条件,需要加上两个字节来凑成4的整数倍 
                    "赖子"


            获取像素数组:
                int line_valid_bytes;//每一行的有效像素数据字节数 
                int line_bytes;//每一行的实际字节数 = 有效字节数 + 癞子数 
                int total_bytes;//整个像素数组的字节数 
                int laizi = 0;//每一行需要填充的字节数 

                line_valid_bytes = abs(width) * (depth/8);

                //判断是否需要癞子 
                if(line_valid_bytes % 4)
                {
                    laizi = 4 - line_valid_bytes%4;
                }
                line_bytes = line_valid_bytes + laizi;
                total_bytes = line_bytes * abs(heigth);

                //现在已经知道了总字节数,我们就需要开始一口气把所有的数据都读取出来 
                unsigned char piexls = malloc(total_bytes);
                lseek(bmp_fd,54,SEEK_SET);
                read(bmp_fd,piexls,total_bytes);


            到这一步,所有像素数据已经读取出来,现在我们就需要对数据进行解析

            小端模式和大端模式:
                在计算机中,数据的存储都是按照字节来的,如果你的数据都是一个字节,那么存储的
                顺序不重要,但是通常数据都是多个字节的,这个时候,存储的顺序就很重要

                小端模式:低地址存低字节的数据,高地址存高字节的数据 
                大端模式:低地址存高字节的数据,高地址存低字节的数据

            我们的处理器是小端模式 
                piexls[0]   piexls[1]   piexls[2]   piexls[3]
                低地址                                  高地址 
                B           G           R           A  

                存储顺序刚好和颜色分量值相反 

                为了得到争取的颜色分量值 ,我们就需要进行位操作 

                color = A<<24 | R<<16 | G<<8 | B;

            解析像素数组:
                unsigned char a,r,g,b;//依次获取每个颜色的分量值 
                int color; 
                int i = 0;//遍历像素数组 
                int x,y;//遍历对应的LCD屏幕 
                for(y = 0;y < abs(heigth);y++)
                {
                    for(x = 0;x < abs(width);x++)
                    {
                        b = piexls[i++];
                        g = piexls[i++];
                        r = piexls[i++];
                        //判断色深是否为32 
                        if(depth == 32)
                        {
                            a = piexls[i++];
                        }
                        else
                        {
                            a = 0;
                        }
                        color = a<<24|r<<16|g<<8|b;
                        //调用画点函数画在LCD屏幕上
                        lcd_draw_point(width>0? x:abs(width)-1-x,height>0? abs(heigth)-1-y:y,color);
                    }
                    i += laiz;//每次跳过癞子数
                }

                free(piexls);



    练习:
        在开发板上显示一张bmp图片 

        1.要准备一张bmp图片 
            可以通过图片转换器来修改
            注意千万别花钱,断开网就OK了

        2.代码框架 
            在打开图片的时候,请打击把你的图片和你的可执行文件都传输到开发板上的工作目录下
            这个你的图片的相对路径 
                "./你的图片名字"
                我的图片名字 1.bmp 
                我的图片路径 "./1.bmp"








